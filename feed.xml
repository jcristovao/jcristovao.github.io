<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Fun Deps</title>
    <link href="http://fundeps.com/feed.xml" rel="self" />
    <link href="http://fundeps.com" />
    <id>http://fundeps.com/feed.xml</id>
    <author>
        <name>Joao Cristovao</name>
        <email>jmacristovao@gmail.com</email>
    </author>
    <updated>2014-03-12T00:00:00Z</updated>
    <entry>
    <title>Monoids, Newtypes and the Evil Human Resources Dept.</title>
    <link href="http://fundeps.com/posts/haskell/2014-03-12-Monoids-Newtypes-and-HR/index.html" />
    <id>http://fundeps.com/posts/haskell/2014-03-12-Monoids-Newtypes-and-HR/index.html</id>
    <published>2014-03-12T00:00:00Z</published>
    <updated>2014-03-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><em>tl;dr:</em> what are those newtypes on monoid good for</p>
<h3 id="the-problem-with-sum">The problem with Sum</h3>
<p>When I read the excelent <a href="http://learnyouahaskell.com/">LYAH</a>, namely the <a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids">monoid</a> section, I must admit at first I didn’t quite get the usefulness of newtypes like <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html#t:Sum">Sum</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html#t:Product">Product</a> or <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html#t:Sum">First</a>.</p>
<p>I mean, let’s take <code>Sum</code>. You have a list of <code>Int</code> that you want to sum. To use this, you must first convert it to the newtype <code>Sum</code></p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Monoid</span>

<span class="kw">let</span> x <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]

<span class="kw">let</span> y <span class="fu">=</span> map <span class="dt">Sum</span> x</code></pre>
<p>And then apply <code>getSum</code> to extract the result:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">let</span> result <span class="fu">=</span> getSum <span class="fu">.</span> mconcat <span class="fu">$</span> y

print result

<span class="fu">&gt;</span> <span class="dv">15</span></code></pre>
<p>It honestly seems dumb for something that can more easily be achieved with:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">let</span> result <span class="fu">=</span> foldr1 (<span class="fu">+</span>) x</code></pre>
<p>Or, even simpler:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">let</span> result <span class="fu">=</span> sum x</code></pre>
<p>So, what’s the point about those Newtypes anyway? Aren’t they more trouble than what their worth?</p>
<h3 id="monoid-records">Monoid records</h3>
<p>My <a href="https://en.wikipedia.org/wiki/Eureka_effect">eureka moment</a> happened in two parts:</p>
<ul>
<li><p>First, I was looking at the <a href="http://hackage.haskell.org/package/semigroups">semigroups</a>, a <a href="http://fundeps.com/posts/haskell/2014-03-05-from-semigroup-to-bind/">simpler</a> version of monoids, and their definition as <em>anything that associates</em> really clicked.</p></li>
<li><p>And then, I discovered <a href="http://hackage.haskell.org/package/generic-deriving-1.6.2/docs/Generics-Deriving-Monoid.html">Generics.Deriving.Monoid</a></p></li>
</ul>
<p>So, if you have a long list of records that you want to combine, you can ‘encode’ how they should be combined in each of the fields using a <code>Monoid</code> newtype. And then, you can automatically derive a monoid instance for the record using generics.</p>
<p>Let’s see an example:</p>
<h3 id="evil-director-of-human-resources">Evil Director of Human Resources</h3>
<p><em>warning: dark humor ahead</em></p>
<p>Let’s say you are an <a href="https://en.wikipedia.org/wiki/Catbert">evil director of HR</a> tasked with choosing a person to assign to a project your company is bidding on. The project has some requirements:</p>
<ul>
<li>The resource must be senior</li>
<li>The resource must have worked in at least three projects before</li>
<li>The resource must have worked with Haskell</li>
</ul>
<p>However, you are not sure if any of your employees fits the profile, as you only hire cheap labor. What should you do?</p>
<p>Easy! You combine each of the employees experience into a single super-profile!</p>
<p>Let start by defining each employee profile:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Generics.Deriving.Monoid</span>

<span class="kw">data</span> <span class="dt">EmployeeProfile</span> <span class="fu">=</span> <span class="dt">EmployeeProfile</span>
  {<span class="ot"> age         ::</span> <span class="dt">First</span> <span class="dt">Int</span> <span class="co">-- for legal reasons, you don&#39;t store the age of some employees</span>
  ,<span class="ot"> numProjects ::</span> <span class="dt">Sum</span> <span class="dt">Int</span>   <span class="co">-- you want to gather as much experience as possible</span>
  ,<span class="ot"> haskell     ::</span> <span class="dt">Any</span>       <span class="co">-- implict boolean</span>
  ,<span class="ot"> python      ::</span> <span class="dt">Any</span>       <span class="co">-- implicit boolean</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Generic</span>)</code></pre>
<p>Now, lets insert our three employees:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">empl0 <span class="fu">=</span> <span class="dt">EmployeeProfile</span> (<span class="dt">First</span> <span class="dt">Nothing</span>)  (<span class="dt">Sum</span> <span class="dv">1</span>) (<span class="dt">Any</span> <span class="dt">False</span>) (<span class="dt">Any</span> <span class="dt">True</span>)
empl1 <span class="fu">=</span> <span class="dt">EmployeeProfile</span> (<span class="dt">First</span> <span class="dt">Nothing</span>)  (<span class="dt">Sum</span> <span class="dv">2</span>) (<span class="dt">Any</span> <span class="dt">True</span> ) (<span class="dt">Any</span> <span class="dt">True</span>)
empl2 <span class="fu">=</span> <span class="dt">EmployeeProfile</span> (<span class="dt">First</span> (<span class="dt">Just</span> <span class="dv">25</span>))(<span class="dt">Sum</span> <span class="dv">0</span>) (<span class="dt">Any</span> <span class="dt">False</span>) (<span class="dt">Any</span> <span class="dt">False</span>)</code></pre>
<p>So, not a great pool of workers. Let’s combine them into a super worker!</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- Generics.Deriving.Monoid magic</span>
<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">EmployeeProfile</span> <span class="kw">where</span>
   mempty  <span class="fu">=</span> memptydefault
   mappend <span class="fu">=</span> mappenddefault

<span class="kw">let</span> greatEmployee <span class="fu">=</span> mconcat [empl0,empl1,empl2]

print greatEmployee 

<span class="fu">&gt;</span> <span class="dt">EmployeeProfile</span> { age <span class="fu">=</span> <span class="dt">First</span> {getFirst <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">25</span>}
				  , numProjects <span class="fu">=</span> <span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">3</span>}
				  , haskell <span class="fu">=</span> <span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}
				  , python <span class="fu">=</span> <span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}}</code></pre>
<p>That’s better! Now you’ve got an employee with 25 years of age, that has worked in three projects and has Haskell experience!</p>
<p>Now imagine what you can do with an enormous pool of mostly unskilled labour! You can almost simulate a very competent Haskell programmer!</p>
<p>This was still a small example, with some added boilerplate. The main catch here is that this boilerplate is always the same independently of the record size, as long as all its fields are monoids themselves.</p>
<p>Some of the fields could benefit from being a semigroup instead of monoid. For example, <code>age</code> should instead be a <a href="http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-Semigroup.html#t:Max">Max</a>, so that we would select the eldest of ages, and thus be more compliant with the seniority requirement. This is still not possible, since Semigroups do not support generic instances, but let’s see if there is <a href="https://github.com/ekmett/semigroups/issues/26">openess to include it</a>.</p>
<p>To extract values from this structure, you also have some additional boilerplate, namely the newtype ‘getter’:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">getAge ::</span> <span class="dt">EmployeeProfile</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
getAge <span class="fu">=</span> getFirst <span class="fu">.</span> age

<span class="ot">hasHaskellExperience ::</span> <span class="dt">EmployeeProfile</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
hasHaskellExperience <span class="fu">=</span> getAny <span class="fu">.</span> haskell</code></pre>
<p>If you are bothered by having to memorize all those ‘getters’ and ‘setters’ (and are not using something more advanced like <a href="http://hackage.haskell.org/package/lens">lenses</a>), you can benefit from Darius Jahandarie package Newtype, that I have modified to include generics support (shameless auto-promotion): <a href="http://hackage.haskell.org/package/newtype-generics">newtype-generics</a></p>
<p>Then, you just have to modify the code to:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Newtype</span>

(<span class="fu">...</span>)

<span class="ot">getAge ::</span> <span class="dt">EmployeeProfile</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
getAge <span class="fu">=</span> unpack <span class="fu">.</span> age

<span class="ot">hasHaskellExperience ::</span> <span class="dt">EmployeeProfile</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
hasHaskellExperience <span class="fu">=</span> unpack <span class="fu">.</span> haskell</code></pre>
<p>Of course, It would be even nicer to automatically extract all the newtypes into a new structure, but as that would give rise to an (undefined / anonymous) new type, something that <a href="https://stackoverflow.com/questions/22299840/derive-a-record-datatype-without-template-haskell">it is not possible without template haskell</a>.</p>
<p>I hope you’ve liked this article. I have not bothered with the details of how generics work, but instead tried to give a more hands on approach of why I found monoid structures useful. Also, please note that I do not condone <em>evil human resources departments</em> :)</p>
<h3 id="addendum">Addendum</h3>
<p>As <a href="http://www.reddit.com/r/haskell/comments/207yjp/monoids_newtypes_and_the_evil_human_resources_dept/cg0p7gt">Edward Kmett points out</a> this practice is not without its problems. You are indeed forcing a monoid structure in your record that may not fullfil all needs.</p>
<p>As he points out, lets suppose you indeed need to find a employee that fullfils all requisites, instead of ‘inventing’ one. Then, you need an intersection.</p>
<p>You would then define a simpler structure:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">EmployeeProfile</span> <span class="fu">=</span> <span class="dt">EmployeeProfile</span>
  {<span class="ot"> age         ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="co">-- for legal reasons, you don&#39;t store the age of some employees</span>
  ,<span class="ot"> numProjects ::</span> <span class="dt">Int</span>   <span class="co">-- you want to gather as much experience as possible</span>
  ,<span class="ot"> haskell     ::</span> <span class="dt">Bool</span>  
  ,<span class="ot"> python      ::</span> <span class="dt">Bool</span> 
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Generic</span>)</code></pre>
<p>and then you could just have this:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">print <span class="fu">$</span> foldMap (\e <span class="ot">-&gt;</span> (<span class="dt">First</span> (age e), <span class="dt">Sum</span> (numProjects e), <span class="dt">All</span> (haskell e))) [empl0,empl1,empl2]</code></pre>
<p>That would return a tuple with the same information, without having to even declare <code>EmployeeProfile</code> as a Monoid, hence forcing a given monoid structure on those fields.</p>
<p>Thus, it is, as usual, a matter of what you intend to do with your data. If you have a long record, with the possibility of adding additional fields later, but you intend to combine them always in the same manner, the solution presented in this post has some clear advantages, since you don’t have to modify the monoid instance manually for each field.</p>
<p>But if you can see yourself needing to extract different information using different monoids, then perhaps you need the simpler data record, and instead you’ll use the <code>Monoid</code> <code>newtypes</code> on your functions, rather than your data structure.</p>
<p>It’s up to you, really :)</p>]]></summary>
</entry>
<entry>
    <title>From semigroups to bind</title>
    <link href="http://fundeps.com/posts/haskell/2014-03-05-from-semigroup-to-bind/index.html" />
    <id>http://fundeps.com/posts/haskell/2014-03-05-from-semigroup-to-bind/index.html</id>
    <published>2014-03-05T00:00:00Z</published>
    <updated>2014-03-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><em>tl;dr:</em> : what are Alt, Apply, Bind typeclasses</p>
<p>So, the one common comment I received on my first <a href="http://fundeps.com/posts/cheatsheets/2014-03-04-cheat-sheets/">haskell cheatsheet</a> was: it looks great, but I have no idea what half of those typeclasses are.</p>
<p>So, I guess an explanation is due.</p>
<p>My first glimpse of understanding came from this <a href="http://hackage.haskell.org/package/semigroupoids">beautiful ASCII art</a>, which I’ll reproduce here:</p>
<pre><code> Traversable &lt;---- Foldable &lt;--- Functor ------&gt; Alt ---------&gt; Plus           Semigroupoid
      |               |            |                              |                  |
      v               v            v                              v                  v
 Traversable1 &lt;--- Foldable1     Apply --------&gt; Applicative -&gt; Alternative      Category
                                   |               |              |                  |
                                   v               v              v                  v
                                 Bind ---------&gt; Monad -------&gt; MonadPlus          Arrow
</code></pre>
<p>So, for the regular haskeller without a background in mathematics,this is what it is usually known:</p>
<p><strong>Monoid</strong>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="kw">where</span>
<span class="ot">        mempty  ::</span> a
        <span class="co">-- ^ Identity of &#39;mappend&#39;</span>
<span class="ot">        mappend ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
        <span class="co">-- ^ An associative operation</span>
<span class="ot">        mconcat ::</span> [a] <span class="ot">-&gt;</span> a</code></pre>
<p><strong>Functor</strong>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p><strong>Applicative:</strong></p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
    <span class="co">-- | Lift a value.</span>
<span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> f a

    <span class="co">-- | Sequential application.</span>
<span class="ot">    (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p><strong>Alternative</strong>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> f <span class="kw">where</span>
    <span class="co">-- | The identity of &#39;&lt;|&gt;&#39;</span>
<span class="ot">    empty ::</span> f a
    <span class="co">-- | An associative binary operation</span>
<span class="ot">    (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</code></pre>
<h2 id="so-what-are-all-those-new-typeclasses">So, what are all those new typeclasses?</h2>
<h4 id="first-question-what-can-i-get-if-i-remove-the-identity-from-a-monoid">First question: <strong>what can I get if I remove the identity (from a Monoid)</strong>?</h4>
<p>You get a <a href="http://hackage.haskell.org/package/semigroups"><strong>semigroup</strong></a></p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span>
  <span class="co">-- | An associative operation.</span>
<span class="ot">  (&lt;&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</code></pre>
<p><em>But, what does it do, that a monoid doesn’t?</em></p>
<p>It gives you <a href="http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-Semigroup.html#t:Min">Min</a> and <a href="http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-Semigroup.html#t:Max">Max</a>. This would not be possible with a monoid. What’s the identity of a Maximum? Do you want to define that?</p>
<p>Plus, you get more instances than you get with monoids, namely <a href="http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-List-NonEmpty.html">Data.List.NonEmpty</a>. This is a list that is type checked to always have at least one element, and thus functions like head always succeed. On the other hand, since there is no ‘empty’ element, this type can only be an instance of Semigroup.</p>
<h4 id="second-question-what-can-i-get-if-i-remove-the-empty-from-an-alternative">Second question: <strong>what can I get if I remove the empty (from an Alternative)</strong>?</h4>
<h5 id="bonus-question-can-i-get-something-that-behaves-like-an-alternative-just-with-a-functor-constraint">Bonus question: <strong>can I get something that behaves like an alternative, just with a Functor constraint?</strong></h5>
<p><em>Yes: It’s called an <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Alt.html">Alt</a></em>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Alt</span> f <span class="kw">where</span>
  <span class="co">-- | @(&lt;|&gt;)@ without a required @empty@</span>
<span class="ot">    (&lt;!&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</code></pre>
<p><em>But, what does it do, that a alternative doesn’t?</em></p>
<p>It allows you to include some extra types, like <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Either.html">Either</a> or IO. Thus, you can write stuff like</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">(<span class="fu">...</span>)
<span class="kw">do</span>
	<span class="co">-- IOAction1 `orElse` IOAction2</span>
	xpto <span class="ot">&lt;-</span> <span class="dt">IOAction1</span> <span class="fu">&lt;!&gt;</span> <span class="dt">IOAction2</span></code></pre>
<h4 id="third-question-what-can-i-get-if-i-remove-the-pure-from-an-applicative">Third question: <strong>what can I get if I remove the pure from an Applicative</strong>?</h4>
<p>An <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Apply.html#t:Apply">Apply</a>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- &gt; associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)</span>
<span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Apply</span> f <span class="kw">where</span>
<span class="ot">  (&lt;.&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p><em>But, what does it do, that a applicative doesn’t?</em></p>
<p>It allows you to include some extra types, like <a href="http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-IntMap-Lazy.html">IntMap</a></p>
<h4 id="fourth-question-what-can-i-get-if-i-remove-the-return-from-a-monad">Fourth question: <strong>what can I get if I remove the return from a Monad</strong>?</h4>
<p>A <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Bind.html#t:Bind">Bind</a></p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Apply</span> m <span class="ot">=&gt;</span> <span class="dt">Bind</span> m <span class="kw">where</span>
<span class="ot">  (&gt;&gt;-) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
  m <span class="fu">&gt;&gt;-</span> f <span class="fu">=</span> join (fmap f m)

<span class="ot">  join ::</span> m (m a) <span class="ot">-&gt;</span> m a
  join <span class="fu">=</span> (<span class="fu">&gt;&gt;-</span> id)</code></pre>
<p><em>But, what does it do, that a monad doesn’t?</em></p>
<p>It allows you to include some extra types, like <a href="http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-IntMap-Lazy.html">IntMap</a></p>
<h4 id="fifth-question-can-i-add-a-zero-value-to-alt">Fifth question: <strong>Can I add a <code>zero</code> value to Alt</strong>?</h4>
<p>Well, this one does seem a little bit far fetched, doesn’t it, since one of the steps of defining Alt was precisely to drop the empty… but, not just that (also just depending on Functor, and not Applicative instances). Hence, <code>zero</code> arrives. Once again, you do gain some extra instances (for example):</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Plus</span> <span class="dt">IO</span> <span class="kw">where</span>
  zero <span class="fu">=</span> error <span class="st">&quot;zero&quot;</span>

<span class="kw">instance</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">Plus</span> (<span class="dt">Map</span> k) <span class="kw">where</span>
  zero <span class="fu">=</span> Map.empty</code></pre>
<p>I call it <em>the reliable empty</em>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>See what I did here? Noticed the pattern?</p>
<p>As an important final note, while you might be mostly used to:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html#t:mempty">mempty</a> means empty</li>
<li><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html#t:mappend">mappend</a> means appending</li>
<li>Alternatives means choice</li>
</ul>
<p>Those are assumptions that do not hold for all types (as I ilustrate on the second page of the <a href="http://fundeps.com/tables/FromSemigroupToMonads.pdf">cheatsheet</a> ).</p>
<p>In fact, once you start thinking about monoids/semigroups as simply <em>binary operations</em>, you start seeing them everywhere, and you start appreciating the usefulness of sometimes dropping the identity/empty/return, etc.</p>
<p><a href="/posts/haskell/2014-03-12-Monoids-Newtypes-and-HR/">In my next post</a> I will ilustrate this, and show how to automatically derive Monoid instances, dramatically reducing your boilerplate.</p>
<p>As usual, please report any typo, error, or gross misundertanding on my part to the email below. Thanks!</p>]]></summary>
</entry>
<entry>
    <title>Haskell Cheat Sheets (Part 1)</title>
    <link href="http://fundeps.com/posts/cheatsheets/2014-03-04-cheat-sheets/index.html" />
    <id>http://fundeps.com/posts/cheatsheets/2014-03-04-cheat-sheets/index.html</id>
    <published>2014-03-04T00:00:00Z</published>
    <updated>2014-03-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><em>tl;dr:</em> : see <a href="/tables/FromSemigroupToMonads.pdf">this</a>.</p>
<p>If you look for Haskell cheat sheets on the web, you get:</p>
<ul>
<li><a href="http://cheatsheet.codeslower.com/CheatSheet.pdf">Code Slower 14 pages cheat sheet</a></li>
<li><a href="http://www.haskell.org/haskellwiki/Reference_card">Haskell Wiki Reference Card</a></li>
<li><a href="http://www.cheat-sheets.org/saved-copy/Haskell.Haskell_Cheat_Sheet.pdf">A short one with the basics</a></li>
<li><a href="https://wincent.com/wiki/Haskell_cheat_sheet">And another one</a></li>
<li><a href="https://github.com/rudymatela/ultimate-cheat-sheets">Ultimate Haskell Cheat Sheet</a></li>
</ul>
<p>Personally, I find none of them particular useful. While the last three are useful for the absolute beginner, it seems that there’s a gap from there forward.</p>
<p>Of course, the usual answer is <a href="https://stackoverflow.com/questions/1162360/haskell-function-cheat-sheet">why do you need a cheat sheet, if there is hoogle</a>, but while <a href="http://www.haskell.org/hoogle/">hoogle</a> and <a href="http://holumbus.fh-wedel.de/hayoo/hayoo.html">hayoo</a> are great, they only help you when you know what you are looking for exactly, namely the type signature.</p>
<p>Sometimes, it is useful to just have a lot information condensed in such a way that’s easy to analyse, so that you can make informed decisions or just easily discover additional functions.</p>
<p>With that purpose in mind, I plan to launch some Haskell cheat sheets, with different levels of complexity and applicability, but with some clear goals in mind:</p>
<ul>
<li>Succinct</li>
<li>Ready to print, for the paper lovers like me</li>
<li>Frequently updated and thus, one expects, always correct</li>
</ul>
<p>The first Haskell sheet cheat I’ll be releasing is one were I illustrate:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/semigroups">Semigroup</a> , <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html">Monoid</a> , <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Alt.html">Alt</a> , <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Plus.html">Plus</a> , <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Apply.html">Apply</a> , <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Applicative">Applicative</a> , <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Alternative">Alternative</a> , <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Bind.html">Bind</a> , <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> , <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:MonadPlus">MonadPlus</a> hierarchy</li>
<li>Fundamental operations supported by each type class</li>
<li>Semantics of the binary operation (Choice, Combination, Both, Neither)</li>
<li>Type Class restrictions</li>
</ul>
<div class="figure">
<img src="/images/fromsemigroup.png" />
</div>
<p><strong>You can get it <a href="/tables/FromSemigroupToMonads.pdf">here</a>.</strong></p>
<p><strong>If you don’t know half of those type classes, please see my <a href="http://fundeps.com/posts/haskell/2014-03-05-from-semigroup-to-bind">next post</a>, for a quick and dirty introduction.</strong></p>
<p>These tables were made incrementally as I was learning each type class. They are still incomplete (namely the second page is still a partial copy-paste of the first), and they are - get ready to puke - in <a href="https://github.com/jcristovao/haskell-cheatsheets">LibreOffice format</a>, not Latex. But for these really complex tables I find it more useful: but I’m open to suggestions.</p>
<p>There are probably some lingering errors, and the table were not, unfortunately, made through automated code analysis. I would very much like that, but right now I see it as a very time consuming task…</p>
<p>Please feel free to identify mistakes, make suggestions or otherwise give your feedback on these. The original file is <a href="https://github.com/jcristovao/haskell-cheatsheets">at GitHub</a>.</p>
<p>Thanks!</p>]]></summary>
</entry>

</feed>
