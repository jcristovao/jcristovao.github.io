<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Fun Deps</title>
    <link href="http://fundeps.com/feed.xml" rel="self" />
    <link href="http://fundeps.com" />
    <id>http://fundeps.com/feed.xml</id>
    <author>
        <name>Joao Cristovao</name>
        <email>jmacristovao@gmail.com</email>
    </author>
    <updated>2014-05-24T00:00:00Z</updated>
    <entry>
    <title>An experiment with typed time</title>
    <link href="http://fundeps.com/posts/haskell/2014-05-24-An-Experiment-with-Typed-Time/index.html" />
    <id>http://fundeps.com/posts/haskell/2014-05-24-An-Experiment-with-Typed-Time/index.html</id>
    <published>2014-05-24T00:00:00Z</published>
    <updated>2014-05-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><em>tl;dr:</em> Using the <a href="http://hackage.haskell.org/package/units">units</a> package for correctly specifying delays</p>
<h2 id="motivation">Motivation</h2>
<p>So, I was doing some experiences with the <a href="http://hackage.haskell.org/package/retry">Retry</a> module, that accepts a base delay as an <code>Int</code> in <em>milliseconds</em>. Then, I was testing this with <code>threadDelay</code> which accepts <em>microseconds</em>.</p>
<p>But the code I was working on actually required delays in the order of seconds, and perhaps even minutes.</p>
<p>As you can now probably guess, this is asking for trouble.</p>
<h2 id="naive-solution">Naive solution</h2>
<p>Well, I could just define functions like these:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- Convert seconds to milliseconds</span>
<span class="ot">secondsToMs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
secondsToMs <span class="fu">=</span> (<span class="fu">*</span><span class="dv">1000</span>)

<span class="co">-- Convert seconds do microseconds</span>
<span class="ot">secondsToUs ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
secondsToUs <span class="fu">=</span> (<span class="fu">*</span><span class="dv">1000000</span>)</code></pre>
<p>But this is still asking for trouble. Nothing is stopping me from mixing seconds with milliseconds with microseconds. Besides, having <code>toUs</code> just feels wrong :P</p>
<h2 id="libraries-ahoy">Libraries ahoy</h2>
<p>Looking in hackage for more type safe solutions yields a lot of libraries. I’ll focus first in two time specific libraries:</p>
<h3 id="tiempo"><a href="https://hackage.haskell.org/package/tiempo">tiempo</a></h3>
<p>Tiempo, found <a href="https://hackage.haskell.org/package/tiempo">here</a> seems to be just a proof-of-concept on expanding the implementation I presented above.</p>
<p>You do get a specific type, <code>TimeInterval</code>, and functions to convert to and from.</p>
<p>However, its interface is far from uniform:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">toMicroSeconds ::</span> <span class="dt">TimeInterval</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">toMilliSeconds ::</span> <span class="dt">TimeInterval</span> <span class="ot">-&gt;</span> <span class="dt">Double</span>
<span class="ot">toSeconds      ::</span> <span class="dt">TimeInterval</span> <span class="ot">-&gt;</span> <span class="dt">Double</span></code></pre>
<p>While I can see why they did this - some base functions dealing with delays use <code>Int</code> as microseconds -, it doesn’t feel clean.</p>
<p>Also, there is no <code>Num</code> instance, thus you can’t even add or subtract <code>TimeInterval</code>s.</p>
<p>However, there is one thing I like in this library: it redefines the <code>threadDelay</code> and <code>timeout</code> functions to accept a TimeInterval, which is one of my goals.</p>
<h3 id="time-units"><a href="https://hackage.haskell.org/package/time-units">time-units</a></h3>
<p>This library, found <a href="https://hackage.haskell.org/package/time-units">here</a>, seems to get some things right. A <code>Num</code> instance makes it easy to declare values:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Time.Units</span>

<span class="kw">let</span> x <span class="fu">=</span> <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Second</span>
print x
<span class="fu">&gt;</span> 5s</code></pre>
<p>And there are separate data types for seconds, minutes, etc, so you can’t accidentally mix them up. You can use the <code>convertUnit</code> to perform (sometimes lossy) conversions.</p>
<p>But, this does imply a somewhat bulky way of adding up times:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Time.Units</span>

<span class="kw">let</span> x <span class="fu">=</span> convertUnit ((<span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Millisecond</span>) <span class="fu">+</span> convertUnit (<span class="dv">6</span><span class="ot"> ::</span> <span class="dt">Second</span>))<span class="ot"> ::</span> <span class="dt">Microsecond</span>
<span class="fu">&gt;</span> <span class="dv">6005000</span>µs</code></pre>
<h2 id="general-unit-libraries">General unit libraries</h2>
<p>Next, I finally stumbled on <a href="http://www.haskell.org/haskellwiki/Physical_units">www.haskell.org/haskellwiki/Physical_units</a>. There are <em>lots</em> of libraries for achieving this, and to be honest, I was a little bit lost.</p>
<p>And if you are hopping for a detailed technical explanation regarding my following choice, I am afraid I don’t have one. I just choose one which seemed to be actively developed, and was mainly focused on unit support. And, of course, that was usable by a dumb guy like me.</p>
<p>Thus, I ended up choosing <a href="http://www.cis.upenn.edu/~eir/packages/units/">units</a> over <a href="http://hackage.haskell.org/package/unittyped">unittyped</a> mainly because the later only has one release in Hackage.</p>
<h3 id="units"><a href="http://hackage.haskell.org/package/units">Units</a></h3>
<p>This library is actually split in two:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/units">units</a> : implements all the Units type hackery. Its type signatures do seem a little daunting, but if you stick with the functions I’ll describe next, you should not have a problem.</li>
<li><a href="https://hackage.haskell.org/package/units-defs">units-defs</a> : The above library does not actually define any Unit besides the very generic Scalar. But you can import units-defs to have access to most (all?) units you might want.</li>
</ul>
<h4 id="minimum-viable-set-of-functions">Minimum viable set of functions</h4>
<p>So, you want to use time. Fine:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Metrology</span>
<span class="kw">import </span><span class="dt">Data.Metrology.SI</span>
<span class="kw">import </span><span class="dt">Data.Metrology.Show</span>

<span class="kw">let</span> x <span class="fu">=</span> <span class="dv">5</span> <span class="fu">%%</span> <span class="dt">Second</span>
<span class="kw">let</span> y <span class="fu">=</span> <span class="dv">6</span> <span class="fu">%%</span> milli <span class="dt">Second</span>
<span class="kw">let</span> z <span class="fu">=</span> x <span class="fu">|+|</span> y 
z
<span class="fu">&gt;</span> <span class="dv">5</span><span class="fu">.</span><span class="dv">006</span> s</code></pre>
<p>Looks great! What if I want the results in microseconds?</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">let</span> ms <span class="fu">=</span> z <span class="st">## micro Second</span>
<span class="fu">&gt;</span> <span class="dv">5006000</span><span class="fu">.</span><span class="dv">0</span></code></pre>
<p>Even better! As you can see, with this solution you can freely mix different values of the same physical quantity, and you always get a correct result. And you can easily convert the final result to the format of your preference.</p>
<p>While there is no <code>Num</code> instance, the <code>|+|</code>, <code>|*|</code>, etc operators do everything you might need.</p>
<p>Thus, while the type signatures do seem a little daunting, the actual use is quite easy!</p>
<p>A notorious disadvantage of this solution is that it uses <a href="http://www.haskell.org/haskellwiki/GHC/Type_families#Closed_family_simplification">closed type families</a>, and thus <a href="https://github.com/goldfirere/units/issues/1">it only supports GHC 7.8.2+</a>. But if you are not bound to a specific GHC version, this is not a major limitation.</p>
<h4 id="implementating-threaddelay">Implementating threadDelay</h4>
<p>So, can we implement a threadDelay which accepts <code>Time</code> as the delay unit?</p>
<p>Yes, let me show you how:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeFamilies  #-}</span>
<span class="kw">module</span> <span class="dt">Control.Concurrent.Units</span>
  ( threadDelay
  , milli
  , micro
  ) <span class="kw">where</span>

<span class="kw">import qualified</span> <span class="dt">Control.Concurrent</span> <span class="kw">as</span> <span class="dt">Conc</span>
<span class="kw">import </span><span class="dt">Data.Metrology</span>
<span class="kw">import </span><span class="dt">Data.Metrology.SI</span>

<span class="co">-- | Modified thread delay that accepts Time.</span>
<span class="ot">threadDelay ::</span> <span class="dt">Time</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
threadDelay t <span class="fu">=</span> Conc.threadDelay (truncate(t <span class="st">## micro Second))</span></code></pre>
<p>So, this is really quite simple, <code>## micro Second</code> converts the result into a (<a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#t:Fractional">Fractional</a>) representation, and then <code>round</code> converts it to an <code>Int</code> acceptable by the <em>old</em> threadDelay (note that round may lose precision).</p>
<h4 id="and-what-about-minutes-and-hours">And what about minutes and hours</h4>
<p>Well, the SI does not define minutes and hours, only seconds. And lets face it, nobody uses <code>kilo seconds</code>.</p>
<p>So, lets add them to our little module:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Minute</span> <span class="fu">=</span> <span class="dt">Minute</span>
<span class="kw">instance</span> <span class="dt">Unit</span> <span class="dt">Minute</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">BaseUnit</span> <span class="dt">Minute</span> <span class="fu">=</span> <span class="dt">Second</span>
  conversionRatio _ <span class="fu">=</span> <span class="dv">60</span>
<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Minute</span> <span class="kw">where</span>
  show _ <span class="fu">=</span> <span class="st">&quot;min&quot;</span>

<span class="kw">data</span> <span class="dt">Hour</span> <span class="fu">=</span> <span class="dt">Hour</span>
<span class="kw">instance</span> <span class="dt">Unit</span> <span class="dt">Hour</span> <span class="kw">where</span>
  <span class="kw">type</span> <span class="dt">BaseUnit</span> <span class="dt">Hour</span> <span class="fu">=</span> <span class="dt">Second</span>
  conversionRatio _ <span class="fu">=</span> <span class="dv">60</span> <span class="fu">*</span> <span class="dv">60</span>
<span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Hour</span> <span class="kw">where</span>
  show _ <span class="fu">=</span> <span class="st">&quot;hour&quot;</span></code></pre>
<p>This is just code copied from <a href="https://hackage.haskell.org/package/units-defs">units-defs</a> Originally I defined <code>Minute</code> and <code>Hour</code> as Prefixes, but <code>5 %% hour Second</code> just didn’t feel right. With the above implementation, I can just type:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">threadDelay (<span class="dv">2</span><span class="fu">.</span><span class="dv">5</span> <span class="fu">%%</span> <span class="dt">Minute</span>)</code></pre>
<h4 id="is-this-a-good-solution">Is this a good solution?</h4>
<p>Well… It is a bit overkill, to be honest. And don’t get illusions of precision when dealing with time, and <code>threadDelay</code>: this is not a <a href="http://en.wikipedia.org/wiki/Real-time_operating_system">RTOS</a>. Please note that this has nothing to do with the units package precision, but the actual use of precise time in a non-real-time operating system as Linux, Windows or OSX.</p>
<p>What this solution <strong>does</strong> allow you is to think naturally in whatever units you prefer, mix them, and have the compiler do the dirty work for you.</p>
<p>And for me, that’s a good enough advantage!</p>
<h3 id="addendum">Addendum</h3>
<ul>
<li><p><strong>PS1</strong>: After talking with <a href="http://www.cis.upenn.edu/~eir/">Richard Eisenberg</a>, one of the library authors, he <a href="https://github.com/goldfirere/units/issues/16">seems open</a> to exchanging the names of the more polymorphic <code>#</code> and <code>%</code> with the monomorphic <code>##</code> and <code>%%</code>. If you have no idea what this means, it is simple: the monomorphic will guess your type much easier, without explicit type annotations. But in the presence of proper type annotations, they should behave the same.</p></li>
<li><p><strong>PS2</strong>: If your interested in this kind of mathematical libraries, two other very popular libraries seems to be the <a href="https://hackage.haskell.org/package/numeric-prelude">numeric-prelude</a> and <a href="https://hackage.haskell.org/package/algebra">algebra</a>, but these are much more general libraries…</p></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Not about arrows</title>
    <link href="http://fundeps.com/posts/cheatsheets/2014-05-14-Not-about-arrows/index.html" />
    <id>http://fundeps.com/posts/cheatsheets/2014-05-14-Not-about-arrows/index.html</id>
    <published>2014-05-14T00:00:00Z</published>
    <updated>2014-05-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><em>tl;dr:</em> Useful arrow combinators everyone uses without really caring for arrows.</p>
<p>Or <strong><em>arrow combinators for dummies</em></strong>.</p>
<!---
***Index***:

* [Not about arrows](#not-about-arrows)
* [What am I missing?](#what-am-i-missing)
    - [Either](#either)
    - [Tuple] (#tupple-pair)
* [Examples, please!](#examples-please)
* [But how does this work?](#how-does-this-work)
* [Is this the right abstraction?](#is-this-the-right-abstraction]
* [Cheatsheet](#cheatsheet)
-->

<h2 id="about">About</h2>
<p>This post is not about arrows <em>per se</em>.</p>
<p>In fact, while arrows are seen as <a href="http://www.haskell.org/arrows/">“a new abstract view of computation (…) as monads (…) but more general”</a>, many Haskell users <em>don’t really care for this</em>. They just use <em>some arrow functions</em> because they implement useful <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Either.html">Either</a> and <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Tuple.html">Tuple</a> combinators.</p>
<p>While there are already <a href="https://en.wikibooks.org/wiki/Haskell/Understanding_arrows">good</a> arrow tutorials, if you’re a beginner, you’ll probably gloss over them, and conclude they seem over complicated for what you are doing.</p>
<p>Heck, don’t even get me started on the <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Arrow.html">Control.Arrow module documentation</a>.</p>
<p>I remember thinking: let me get these monads straight, then monad transformers, those are also quite used, <em>then</em> I’ll consider arrows. And I argue that many haskellers never do get to that point…</p>
<h2 id="what-am-i-missing">What am I missing?</h2>
<p>One of Arrow instances is function application, or <code>-&gt;</code>.</p>
<p>How is that useful?</p>
<h3 id="either">Either</h3>
<p>Many of you have probably wondered why there aren’t functions on <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Either.html">base</a> to map the <code>Left</code> part of an Either, or even both <code>Left</code> and <code>Right</code>.</p>
<p>You are <a href="http://www.haskell.org/pipermail/libraries/2014-April/022679.html">not</a> <a href="https://stackoverflow.com/questions/13503965/mapping-over-eithers-left">alone</a>. My guess is that this question will just keep on popping until proper documentation is added to Data.Either.</p>
<p>While you might later find these defined in the very useful module <a href="http://hackage.haskell.org/package/either">either</a>, namely <a href="http://hackage.haskell.org/package/either-4.1.1/docs/Data-Either-Combinators.html">Data.Either.Combinators</a>, as <a href="https://hackage.haskell.org/package/either-4.1.1/docs/Data-Either-Combinators.html#v:mapLeft">mapLeft</a> and <a href="http://hackage.haskell.org/package/either-4.1.1/docs/Data-Either-Combinators.html#v:mapBoth">mapBoth</a>, what you might miss is that you don’t require an extra package to get this: you can use <code>Control.Arrow</code> from base!</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- Apply a function  to the left side of an Either</span>
<span class="co">-- The same as &#39;mapLeft&#39; from Data.Either.Combinators</span>
<span class="ot">left ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Either</span> b d <span class="ot">-&gt;</span> <span class="dt">Either</span> c d

<span class="co">-- Apply a function to the right side of an Either</span>
<span class="co">-- the same as &#39;mapRight&#39; from Data.Either.Combinators</span>
<span class="co">-- but you should just used &#39;fmap&#39; instead</span>
<span class="ot">right ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">Either</span> d b <span class="ot">-&gt;</span> <span class="dt">Either</span> d c

<span class="co">-- Apply one of the provided functions to the Either value,</span>
<span class="co">-- resulting from the case analysis.</span>
<span class="co">-- The same as &#39;mapBoth&#39; from Data.Either.Combinators</span>
<span class="ot">(+++) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b&#39; <span class="ot">-&gt;</span> c&#39;) <span class="ot">-&gt;</span> <span class="dt">Either</span> b b&#39; <span class="ot">-&gt;</span> <span class="dt">Either</span> c c&#39;

<span class="co">-- Case analysis.</span>
<span class="co">-- The same as &#39;either&#39;</span>
<span class="ot">(|||) ::</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> <span class="dt">Either</span> b c <span class="ot">-&gt;</span> d</code></pre>
<h3 id="tuple-pair">2-Tuple (Pair)</h3>
<p>Another useful set of arrow combinators applies to Tuples:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- Apply a function to first pair element</span>
<span class="ot">first ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b,d) <span class="ot">-&gt;</span> (c,d)

<span class="co">-- Apply a function to second pair element</span>
<span class="co">-- but you should just use &#39;fmap&#39; instead</span>
<span class="ot">second ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (d,b) <span class="ot">-&gt;</span> (d,c)

<span class="co">-- Apply the first function to the first element,</span>
<span class="co">-- and the second function to the second element.</span>
<span class="ot">(***) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b&#39; <span class="ot">-&gt;</span> c&#39;) <span class="ot">-&gt;</span> (b,b&#39;) <span class="ot">-&gt;</span> (c,c&#39;)

<span class="co">-- Value to pair (fanout)</span>
<span class="ot">(&amp;&amp;&amp;) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c&#39;) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> (c,c&#39;)</code></pre>
<h2 id="examples-please">Examples, please!</h2>
<h3 id="modify-both-elements-of-a-tuple">Modify both elements of a tuple</h3>
<p><small style="color:brown">the following examples can be copy-pasted into ghci</small></p>
<p>Lets say you’ve got a string that you want to quickly split into two, and process each part independently. You could use <a href="http://hackage.haskell.org/package/attoparsec">attoparsec</a>, but perhaps for a one time use you would prefer to avoid adding any other module.</p>
<p>So, you start by using <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#v:break"><code>break</code></a>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">let</span> x           <span class="fu">=</span> <span class="st">&quot;1_test&quot;</span>
<span class="kw">let</span> splitPair <span class="fu">=</span> break (<span class="fu">==</span><span class="ch">&#39;_&#39;</span>) x    <span class="co">-- (&quot;1&quot;,&quot;_test&quot;)</span></code></pre>
<p>And now, you would like to <code>read</code> the first tuple element, and drop the underscore from the second. Usually, you would do this:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">let</span><span class="ot"> numStr ::</span> (<span class="dt">Int</span>,<span class="dt">String</span>) ; numStr <span class="fu">=</span> (\(a,b) <span class="ot">-&gt;</span> (read a, drop <span class="dv">1</span> b)) splitPair</code></pre>
<p>And you get the intended <code>(1,&quot;test&quot;)</code></p>
<p>Now, how would you do this with arrows?</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Arrow</span>
(<span class="fu">...</span>)
<span class="kw">let</span><span class="ot"> numStr ::</span> (<span class="dt">Int</span>,<span class="dt">String</span>) ; numStr <span class="fu">=</span> read <span class="fu">***</span> drop <span class="dv">1</span> <span class="fu">$</span> splitPair</code></pre>
<p>Much cleaner.</p>
<h3 id="change-the-left-type-of-a-either">Change the Left type of a Either</h3>
<p>Since a <code>Monad</code> takes a type constructor with exactly one type, it is not possible to provide a <code>Monad</code> instance for <code>Either</code> alone. You must specify its <code>Left</code> type (hence fixing it).</p>
<p>A simple example:</p>
<div class="alert alert-danger">
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import </span><span class="dt">Data.Either</span>
<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="co">-- Lets say most of our code is on the Either Text Int monad...</span>
<span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Int</span>
f x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">&gt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Right</span> x
               <span class="kw">else</span> <span class="dt">Left</span> <span class="st">&quot;Not bigger than 0&quot;</span>

<span class="co">-- But by an unfortunate event, we need to use a function</span>
<span class="co">-- that returns a different Left type</span>
<span class="ot">g ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Int</span>
g y <span class="fu">=</span> <span class="kw">if</span> y <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Right</span> y
                        <span class="kw">else</span> <span class="dt">Left</span> <span class="st">&quot;Not divisible by 3&quot;</span>

<span class="ot">eitherMonad ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Int</span>
eitherMonad x y w z <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> f x
  b <span class="ot">&lt;-</span> g y <span class="co">-- it fails here! g is a different monad!</span>
  c <span class="ot">&lt;-</span> f w
  d <span class="ot">&lt;-</span> f z
  return <span class="fu">$</span> a <span class="fu">*</span> b <span class="fu">+</span> <span class="dv">2</span> <span class="fu">*</span> c <span class="fu">+</span> d

main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> eitherMonad <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="co">-- not divisible by 3</span>
  print <span class="fu">$</span> eitherMonad <span class="dv">1</span> <span class="dv">9</span> <span class="dv">0</span> <span class="dv">4</span> <span class="co">-- not bigger than 0</span>
  print <span class="fu">$</span> eitherMonad <span class="dv">0</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">4</span> <span class="co">-- not divisible by 3</span>
                              <span class="co">-- it only reports the first left</span>
  print <span class="fu">$</span> eitherMonad <span class="dv">1</span> <span class="dv">9</span> <span class="dv">3</span> <span class="dv">4</span> <span class="co">-- it should return 19</span>
                              <span class="co">-- but it doesn&#39;t, because this </span>
                              <span class="co">-- code does not compile</span></code></pre>
</div>
<p>Using <code>left</code>, we can modify the <code>Left</code> side of the <code>Either</code>, and thus keep working in the same monad:</p>
<div class="alert alert-success">
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE OverloadedStrings #-}</span>
<span class="kw">import </span><span class="dt">Data.Either</span>
<span class="kw">import </span><span class="dt">Data.Text</span>
<span class="kw">import </span><span class="dt">Control.Arrow</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>

<span class="co">-- Lets say most of our code is on the Either Text Int monad...</span>
<span class="ot">f ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Int</span>
f x <span class="fu">=</span> <span class="kw">if</span> x <span class="fu">&gt;</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Right</span> x
               <span class="kw">else</span> <span class="dt">Left</span> <span class="st">&quot;Not bigger than 0&quot;</span>

<span class="co">-- But by an unfortunate event, we need to use a function</span>
<span class="co">-- that returns a different Left type</span>
<span class="ot">g ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> <span class="dt">Int</span>
g y <span class="fu">=</span> <span class="kw">if</span> y <span class="ot">`mod`</span> <span class="dv">3</span> <span class="fu">==</span> <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Right</span> y
                        <span class="kw">else</span> <span class="dt">Left</span> <span class="st">&quot;Not divisible by 3&quot;</span>

<span class="ot">eitherMonad ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">Text</span> <span class="dt">Int</span>
eitherMonad x y w z <span class="fu">=</span> <span class="kw">do</span>
  a <span class="ot">&lt;-</span> f x
  b <span class="ot">&lt;-</span> left pack <span class="fu">$</span> g y <span class="co">-- it now works!</span>
  c <span class="ot">&lt;-</span> f w
  d <span class="ot">&lt;-</span> f z
  return <span class="fu">$</span> a <span class="fu">*</span> b <span class="fu">+</span> <span class="dv">2</span> <span class="fu">*</span> c <span class="fu">+</span> d

main <span class="fu">=</span> <span class="kw">do</span>
  print <span class="fu">$</span> eitherMonad <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="co">-- not divisible by 3</span>
  print <span class="fu">$</span> eitherMonad <span class="dv">1</span> <span class="dv">9</span> <span class="dv">0</span> <span class="dv">4</span> <span class="co">-- not bigger than 0</span>
  print <span class="fu">$</span> eitherMonad <span class="dv">0</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">4</span> <span class="co">-- not divisible by 3</span>
                              <span class="co">-- it only reports the first left</span>
  print <span class="fu">$</span> eitherMonad <span class="dv">1</span> <span class="dv">9</span> <span class="dv">3</span> <span class="dv">4</span> <span class="co">-- OK! returns 19</span>
                                                                                                                               </code></pre>
</div>
<h2 id="but-how-does-this-all-work">But how does this all work?</h2>
<p>The strange thing is when you look at the functions signatures in <code>Control.Arrow</code>, they do not seem applicable:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">
<span class="co">-- | Feed marked inputs through the argument arrow,</span>
<span class="co">--   passing the rest through unchanged to the output.</span>
<span class="ot">left ::</span> a b c <span class="ot">-&gt;</span> a (<span class="dt">Either</span> b d) (<span class="dt">Either</span> c d)

<span class="co">-- | A mirror image of left.</span>
<span class="ot">right ::</span> a b c <span class="ot">-&gt;</span> a (<span class="dt">Either</span> d b) (<span class="dt">Either</span> d c)

<span class="co">-- | Split the input between the two argument arrows,</span>
<span class="co">--   retagging and merging their outputs.</span>
<span class="ot">(+++) ::</span> a b c <span class="ot">-&gt;</span> a b&#39; c&#39; <span class="ot">-&gt;</span> a (<span class="dt">Either</span> b b&#39;) (<span class="dt">Either</span> c c&#39;) 

<span class="co">-- | Fanin: Split the input between the two argument arrows </span>
<span class="co">--   and merge their outputs.</span>
<span class="ot">(|||) ::</span> a b d <span class="ot">-&gt;</span> a c d <span class="ot">-&gt;</span> a (<span class="dt">Either</span> b c) d </code></pre>
<p>However, if you consider that function application, also represente as an <code>-&gt;</code>, is an instance of <code>Arrow</code>, things get more clear… How? Just replace <code>a</code> with <code>-&gt;</code>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">
<span class="co">-- | Feed marked inputs through the argument arrow,</span>
<span class="co">--   passing the rest through unchanged to the output.</span>
<span class="ot">left ::</span> a    b c <span class="ot">-&gt;</span> a    (<span class="dt">Either</span> b d)  (<span class="dt">Either</span> c d)
<span class="ot">     ::</span> (<span class="ot">-&gt;</span>) b c <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (<span class="dt">Either</span> b d)  (<span class="dt">Either</span> c d) 
<span class="ot">     ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span>       <span class="dt">Either</span> b d <span class="ot">-&gt;</span> <span class="dt">Either</span> c d

<span class="co">-- | A mirror image of left.</span>
<span class="ot">right ::</span> a    b c <span class="ot">-&gt;</span> a    (<span class="dt">Either</span> d b)  (<span class="dt">Either</span> d c) 
<span class="ot">      ::</span> (<span class="ot">-&gt;</span>) b c <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (<span class="dt">Either</span> d b)  (<span class="dt">Either</span> d c) 
<span class="ot">      ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span>       <span class="dt">Either</span> d b <span class="ot">-&gt;</span> <span class="dt">Either</span> d c

<span class="co">-- | Split the input between the two argument arrows,</span>
<span class="co">--   retagging and merging their outputs.</span>
<span class="ot">(+++) ::</span> a    b c <span class="ot">-&gt;</span> a    b&#39; c&#39; <span class="ot">-&gt;</span> a    (<span class="dt">Either</span> b b&#39;)  (<span class="dt">Either</span> c c&#39;) 
<span class="ot">      ::</span> (<span class="ot">-&gt;</span>) b c <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) b&#39; c&#39; <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (<span class="dt">Either</span> b b&#39;)  (<span class="dt">Either</span> c c&#39;) 
<span class="ot">      ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b&#39; <span class="ot">-&gt;</span> c&#39;) <span class="ot">-&gt;</span>       <span class="dt">Either</span> b b&#39; <span class="ot">-&gt;</span> <span class="dt">Either</span> c c&#39;

<span class="co">-- | Fanin: Split the input between the two argument arrows </span>
<span class="co">--   and merge their outputs.</span>
<span class="ot">(|||) ::</span> a    b d <span class="ot">-&gt;</span> a    c d <span class="ot">-&gt;</span> a    (<span class="dt">Either</span> b c)   d 
<span class="ot">      ::</span> (<span class="ot">-&gt;</span>) b d <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) c d <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (<span class="dt">Either</span> b c)   d
<span class="ot">      ::</span> (b <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span>       <span class="dt">Either</span> b c <span class="ot">-&gt;</span> d</code></pre>
<p>And the same applies for Pairs:</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- | send the first component of the input through the argument </span>
<span class="co">-- arrow, and copy the rest unchanged to the output.</span>
<span class="ot">first ::</span> a    b c <span class="ot">-&gt;</span> a    (b, d)   (c,d)
<span class="ot">      ::</span> (<span class="ot">-&gt;</span>) b c <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (b,d)    (c,d)
<span class="ot">      ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span>      (b,d) <span class="ot">-&gt;</span> (c,d)
     
<span class="co">-- | a mirror image of first.</span>
<span class="ot">second ::</span> a    b c <span class="ot">-&gt;</span> a     (d, b)    (d, c)
<span class="ot">       ::</span> (<span class="ot">-&gt;</span>) b c <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>)  (d, b)    (d, c)
<span class="ot">       ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span>       (d, b) <span class="ot">-&gt;</span> (d, c)


<span class="co">-- | split the input between the two argument arrows</span>
<span class="co">--   and combine their output.</span>
<span class="ot">(***) ::</span> a    b c <span class="ot">-&gt;</span> a    b&#39; c&#39; <span class="ot">-&gt;</span> a    (b, b&#39;)    (c, c&#39;)
<span class="ot">      ::</span> (<span class="ot">-&gt;</span>) b c <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) b&#39; c&#39; <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) (b, b&#39;)    (c, c&#39;)
<span class="ot">      ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b&#39; <span class="ot">-&gt;</span> c&#39;) <span class="ot">-&gt;</span>      (b, b&#39;) <span class="ot">-&gt;</span> (c, c&#39;)

<span class="co">-- | fanout: send the input to both argument arrows</span>
<span class="co">--   and combine their output.</span>
<span class="ot">(&amp;&amp;&amp;) ::</span> a    b c <span class="ot">-&gt;</span> a    b c&#39; <span class="ot">-&gt;</span> a    b    (c, c&#39;)
<span class="ot">      ::</span> (<span class="ot">-&gt;</span>) b c <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) b c&#39; <span class="ot">-&gt;</span> (<span class="ot">-&gt;</span>) b    (c, c&#39;)
<span class="ot">      ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c&#39;) <span class="ot">-&gt;</span>      b <span class="ot">-&gt;</span> (c, c&#39;)</code></pre>
<h2 id="is-this-the-right-abstraction">Is this the right abstraction?</h2>
<p>The <a href="http://www.haskell.org/pipermail/libraries/2014-April/022777.html">current</a> <a href="http://www.haskell.org/pipermail/libraries/2014-April/022844.html">effort</a> to add more straight forward functions to <code>Data.Either</code> and <code>Data.Tuple</code> ended with the conclusiong that <a href="http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html">Bifunctors</a> should be added to base.</p>
<p>Bifunctors are really nice, and a much more (IMHO) logical way to present these operators. Take any given type constructor that parameterizes over two types, make it pass some very obvious rules (<code>bimap id id ≡ id</code>), and you got yourself something that it is just like a <code>Functor</code>, but for “bi-types”.</p>
<p>So, <code>Either</code> is an instance, and so is <code>(,)</code>. And the equivalent functions are the very obvious:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Bifunctor</span> p <span class="kw">where</span>
    <span class="co">-- |  Map over both arguments at the same time.</span>
<span class="ot">    bimap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b d

    <span class="co">-- | Map covariantly over the first argument.</span>
<span class="ot">    first ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a c <span class="ot">-&gt;</span> p b c

    <span class="co">-- | Map covariantly over the second argument.</span>
<span class="ot">    second ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c</code></pre>
<p>While this is, IMHO, not a bad outcome at all, I still feel that more straight-forward functions on <code>Data.Either</code> and <code>Data.Tuple</code> would do more good than harm, namely easing the way for Haskell newbies.</p>
<p>But the <code>Bifunctor</code> is a very useful (and logical) abstraction, and it is definitely most welcomed.</p>
<h2 id="cheatsheet">Cheatsheet</h2>
<p>So, arrows operators can be quite useful for types that are parameterized over two types: <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Either.html">Either</a> for choice, <a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Data-Tuple.html">Tuple</a> for combinations.</p>
<table class="table table-striped">
  <thead>
    <tr>
        <th>
Apply function to
</th>
        <th>
Type
</th>
        <th>
Arrow<br />Operator
</th>
        <th>
Alternative<br />in Base
</th>
        <th>
Alternative<br />in <a href="https://hackage.haskell.org/package/either">either</a>
</th>
        <th>
Alternative<br />in <a href="http://hackage.haskell.org/package/bifunctors">bifunctor</a>
</th>
        </tr>
  </thead>
  <tbody class="table-striped">
    <tr><td>
First type
</td>
		<td>
Either
</td>
		<td>
<a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Arrow.html#v:left">left</a>
</td>
        <td></td>
        <td>
<a href="https://hackage.haskell.org/package/either-4.1.1/docs/Data-Either-Combinators.html#v:mapLeft">mapLeft</a>
</td>
        <td>
<a href="http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html#v:first">first</a>
</td>
    </tr>
    <tr><td>            </td>
		<td>
(,)
</td>
		<td>
<a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Arrow.html#v:first">first</a>
</td>
        <td></td>
        <td></td>
        <td>
<a href="http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html#v:first">first</a>
</td>
    </tr>
    <tr><td>
Second type
</td>
		<td>
Either
</td>
		<td>
<a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Arrow.html#v:right">right</a>
</td>
        <td>
<a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#v:fmap">fmap</a>
</td>
        <td>
<a href="https://hackage.haskell.org/package/either-4.1.1/docs/Data-Either-Combinators.html#v:mapRight">mapRight</a>
</td>
        <td>
<a href="http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html#v:second">second</a>
</td>
    </tr>
    <tr><td>            </td>
		<td>
(,)
</td>
		<td>
<a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Arrow.html#v:second">second</a>
</td>
        <td>
<a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Prelude.html#v:fmap">fmap</a>
</td>
        <td></td>
        <td>
<a href="http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html#v:second">second</a>
</td>
    </tr>
    <tr><td>
Both types
</td>
		<td>
Either
</td>
		<td>
<a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Arrow.html#v:-43--43--43-">(+++)</a>
</td>
        <td></td>
        <td>
<a href="https://hackage.haskell.org/package/either-4.1.1/docs/Data-Either-Combinators.html#v:mapBoth">mapBoth</a>
</td>
        <td>
<a href="http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html#v:bimap">bimap</a>
</td>
    </tr>
    <tr><td>            </td>
		<td>
(,)
</td>
		<td>
<a href="http://hackage.haskell.org/package/base-4.7.0.0/docs/Control-Arrow.html#v:-42--42--42-">(***)</a>
</td>
        <td></td>
        <td></td>
        <td>
<a href="http://hackage.haskell.org/package/bifunctors-3.2.0.1/docs/Data-Bifunctor.html#v:bimap">bimap</a>
</td>
    </tr>
  </tbody>
</table>


<h2 id="function-composition">Function composition</h2>
<p>Finally, there is yet another gem hidden in the <code>-&gt;</code> instance of <code>Arrow</code>: function composition.</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- | Left-to-right composition</span>
<span class="ot">(&gt;&gt;&gt;) ::</span> <span class="dt">Category</span> cat <span class="ot">=&gt;</span> cat a b <span class="ot">-&gt;</span> cat b c <span class="ot">-&gt;</span> cat a c 

<span class="co">-- | Right-to-left composition</span>
<span class="ot">(&lt;&lt;&lt;) ::</span> <span class="dt">Category</span> cat <span class="ot">=&gt;</span> cat b c <span class="ot">-&gt;</span> cat a b <span class="ot">-&gt;</span> cat a c </code></pre>
<p>Where again, replacing <code>cat</code> with <code>-&gt;</code> gets you the expected result. However, once again, there is a better abstraction for this.</p>
<p>If you only need left-to-right function composition, you should probably just import <a href="http://hackage.haskell.org/package/base-4.6.0.0/docs/Control-Category.html">Control.Category</a>, which has been on <code>Base</code> at least since version 4.0.</p>
<h2 id="conclusion">Conclusion</h2>
<p>I hope you have liked this introductory text. Please let me know what you think, and if you found any error or typo. None of this is especially new, but my intent was to join all this information in one place. If there is an equivalent guide somewhere else, please let me know.</p>
<p>Cheers, João</p>]]></summary>
</entry>
<entry>
    <title>Monoids, Newtypes and the Evil Human Resources Dept.</title>
    <link href="http://fundeps.com/posts/haskell/2014-03-12-Monoids-Newtypes-and-HR/index.html" />
    <id>http://fundeps.com/posts/haskell/2014-03-12-Monoids-Newtypes-and-HR/index.html</id>
    <published>2014-03-12T00:00:00Z</published>
    <updated>2014-03-12T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><em>tl;dr:</em> what are those newtypes on monoid good for</p>
<h3 id="the-problem-with-sum">The problem with Sum</h3>
<p>When I read the excelent <a href="http://learnyouahaskell.com/">LYAH</a>, namely the <a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids">monoid</a> section, I must admit at first I didn’t quite get the usefulness of newtypes like <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html#t:Sum">Sum</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html#t:Product">Product</a> or <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html#t:Sum">First</a>.</p>
<p>I mean, let’s take <code>Sum</code>. You have a list of <code>Int</code> that you want to sum. To use this, you must first convert it to the newtype <code>Sum</code></p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Data.Monoid</span>

<span class="kw">let</span> x <span class="fu">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>]

<span class="kw">let</span> y <span class="fu">=</span> map <span class="dt">Sum</span> x</code></pre>
<p>And then apply <code>getSum</code> to extract the result:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">let</span> result <span class="fu">=</span> getSum <span class="fu">.</span> mconcat <span class="fu">$</span> y

print result

<span class="fu">&gt;</span> <span class="dv">15</span></code></pre>
<p>It honestly seems dumb for something that can more easily be achieved with:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">let</span> result <span class="fu">=</span> foldr1 (<span class="fu">+</span>) x</code></pre>
<p>Or, even simpler:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">let</span> result <span class="fu">=</span> sum x</code></pre>
<p>So, what’s the point about those Newtypes anyway? Aren’t they more trouble than what their worth?</p>
<h3 id="monoid-records">Monoid records</h3>
<p>My <a href="https://en.wikipedia.org/wiki/Eureka_effect">eureka moment</a> happened in two parts:</p>
<ul>
<li><p>First, I was looking at the <a href="http://hackage.haskell.org/package/semigroups">semigroups</a>, a <a href="http://fundeps.com/posts/haskell/2014-03-05-from-semigroup-to-bind/">simpler</a> version of monoids, and their definition as <em>anything that associates</em> really clicked.</p></li>
<li><p>And then, I discovered <a href="http://hackage.haskell.org/package/generic-deriving-1.6.2/docs/Generics-Deriving-Monoid.html">Generics.Deriving.Monoid</a></p></li>
</ul>
<p>So, if you have a long list of records that you want to combine, you can ‘encode’ how they should be combined in each of the fields using a <code>Monoid</code> newtype. And then, you can automatically derive a monoid instance for the record using generics.</p>
<p>Let’s see an example:</p>
<h3 id="evil-director-of-human-resources">Evil Director of Human Resources</h3>
<p><em>warning: dark humor ahead</em></p>
<p>Let’s say you are an <a href="https://en.wikipedia.org/wiki/Catbert">evil director of HR</a> tasked with choosing a person to assign to a project your company is bidding on. The project has some requirements:</p>
<ul>
<li>The resource must be senior</li>
<li>The resource must have worked in at least three projects before</li>
<li>The resource must have worked with Haskell</li>
</ul>
<p>However, you are not sure if any of your employees fits the profile, as you only hire cheap labor. What should you do?</p>
<p>Easy! You combine each of the employees experience into a single super-profile!</p>
<p>Let start by defining each employee profile:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span>
<span class="kw">import </span><span class="dt">GHC.Generics</span>
<span class="kw">import </span><span class="dt">Generics.Deriving.Monoid</span>

<span class="kw">data</span> <span class="dt">EmployeeProfile</span> <span class="fu">=</span> <span class="dt">EmployeeProfile</span>
  {<span class="ot"> age         ::</span> <span class="dt">First</span> <span class="dt">Int</span> <span class="co">-- for legal reasons, you don&#39;t store the age of some employees</span>
  ,<span class="ot"> numProjects ::</span> <span class="dt">Sum</span> <span class="dt">Int</span>   <span class="co">-- you want to gather as much experience as possible</span>
  ,<span class="ot"> haskell     ::</span> <span class="dt">Any</span>       <span class="co">-- implict boolean</span>
  ,<span class="ot"> python      ::</span> <span class="dt">Any</span>       <span class="co">-- implicit boolean</span>
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Generic</span>)</code></pre>
<p>Now, lets insert our three employees:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">empl0 <span class="fu">=</span> <span class="dt">EmployeeProfile</span> (<span class="dt">First</span> <span class="dt">Nothing</span>)  (<span class="dt">Sum</span> <span class="dv">1</span>) (<span class="dt">Any</span> <span class="dt">False</span>) (<span class="dt">Any</span> <span class="dt">True</span>)
empl1 <span class="fu">=</span> <span class="dt">EmployeeProfile</span> (<span class="dt">First</span> <span class="dt">Nothing</span>)  (<span class="dt">Sum</span> <span class="dv">2</span>) (<span class="dt">Any</span> <span class="dt">True</span> ) (<span class="dt">Any</span> <span class="dt">True</span>)
empl2 <span class="fu">=</span> <span class="dt">EmployeeProfile</span> (<span class="dt">First</span> (<span class="dt">Just</span> <span class="dv">25</span>))(<span class="dt">Sum</span> <span class="dv">0</span>) (<span class="dt">Any</span> <span class="dt">False</span>) (<span class="dt">Any</span> <span class="dt">False</span>)</code></pre>
<p>So, not a great pool of workers. Let’s combine them into a super worker!</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- Generics.Deriving.Monoid magic</span>
<span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">EmployeeProfile</span> <span class="kw">where</span>
   mempty  <span class="fu">=</span> memptydefault
   mappend <span class="fu">=</span> mappenddefault

<span class="kw">let</span> greatEmployee <span class="fu">=</span> mconcat [empl0,empl1,empl2]

print greatEmployee 

<span class="fu">&gt;</span> <span class="dt">EmployeeProfile</span> { age <span class="fu">=</span> <span class="dt">First</span> {getFirst <span class="fu">=</span> <span class="dt">Just</span> <span class="dv">25</span>}
				  , numProjects <span class="fu">=</span> <span class="dt">Sum</span> {getSum <span class="fu">=</span> <span class="dv">3</span>}
				  , haskell <span class="fu">=</span> <span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}
				  , python <span class="fu">=</span> <span class="dt">Any</span> {getAny <span class="fu">=</span> <span class="dt">True</span>}}</code></pre>
<p>That’s better! Now you’ve got an employee with 25 years of age, that has worked in three projects and has Haskell experience!</p>
<p>Now imagine what you can do with an enormous pool of mostly unskilled labour! You can almost simulate a very competent Haskell programmer!</p>
<p>This was still a small example, with some added boilerplate. The main catch here is that this boilerplate is always the same independently of the record size, as long as all its fields are monoids themselves.</p>
<p>Some of the fields could benefit from being a semigroup instead of monoid. For example, <code>age</code> should instead be a <a href="http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-Semigroup.html#t:Max">Max</a>, so that we would select the eldest of ages, and thus be more compliant with the seniority requirement. This is still not possible, since Semigroups do not support generic instances, but let’s see if there is <a href="https://github.com/ekmett/semigroups/issues/26">openess to include it</a>.</p>
<p>To extract values from this structure, you also have some additional boilerplate, namely the newtype ‘getter’:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="ot">getAge ::</span> <span class="dt">EmployeeProfile</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
getAge <span class="fu">=</span> getFirst <span class="fu">.</span> age

<span class="ot">hasHaskellExperience ::</span> <span class="dt">EmployeeProfile</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
hasHaskellExperience <span class="fu">=</span> getAny <span class="fu">.</span> haskell</code></pre>
<p>If you are bothered by having to memorize all those ‘getters’ and ‘setters’ (and are not using something more advanced like <a href="http://hackage.haskell.org/package/lens">lenses</a>), you can benefit from Darius Jahandarie package Newtype, that I have modified to include generics support (shameless auto-promotion): <a href="http://hackage.haskell.org/package/newtype-generics">newtype-generics</a></p>
<p>Then, you just have to modify the code to:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Control.Newtype</span>

(<span class="fu">...</span>)

<span class="ot">getAge ::</span> <span class="dt">EmployeeProfile</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
getAge <span class="fu">=</span> unpack <span class="fu">.</span> age

<span class="ot">hasHaskellExperience ::</span> <span class="dt">EmployeeProfile</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
hasHaskellExperience <span class="fu">=</span> unpack <span class="fu">.</span> haskell</code></pre>
<p>Of course, It would be even nicer to automatically extract all the newtypes into a new structure, but as that would give rise to an (undefined / anonymous) new type, something that <a href="https://stackoverflow.com/questions/22299840/derive-a-record-datatype-without-template-haskell">it is not possible without template haskell</a>.</p>
<p>I hope you’ve liked this article. I have not bothered with the details of how generics work, but instead tried to give a more hands on approach of why I found monoid structures useful. Also, please note that I do not condone <em>evil human resources departments</em> :)</p>
<h3 id="addendum">Addendum</h3>
<p>As <a href="http://www.reddit.com/r/haskell/comments/207yjp/monoids_newtypes_and_the_evil_human_resources_dept/cg0p7gt">Edward Kmett points out</a> this practice is not without its problems. You are indeed forcing a monoid structure in your record that may not fullfil all needs.</p>
<p>As he points out, lets suppose you indeed need to find a employee that fullfils all requisites, instead of ‘inventing’ one. Then, you need an intersection.</p>
<p>You would then define a simpler structure:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">EmployeeProfile</span> <span class="fu">=</span> <span class="dt">EmployeeProfile</span>
  {<span class="ot"> age         ::</span> <span class="dt">Maybe</span> <span class="dt">Int</span> <span class="co">-- for legal reasons, you don&#39;t store the age of some employees</span>
  ,<span class="ot"> numProjects ::</span> <span class="dt">Int</span>   <span class="co">-- you want to gather as much experience as possible</span>
  ,<span class="ot"> haskell     ::</span> <span class="dt">Bool</span>  
  ,<span class="ot"> python      ::</span> <span class="dt">Bool</span> 
  } <span class="kw">deriving</span> (<span class="dt">Eq</span>,<span class="dt">Ord</span>,<span class="dt">Show</span>,<span class="dt">Generic</span>)</code></pre>
<p>and then you could just have this:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">print <span class="fu">$</span> foldMap (\e <span class="ot">-&gt;</span> (<span class="dt">First</span> (age e), <span class="dt">Sum</span> (numProjects e), <span class="dt">All</span> (haskell e))) [empl0,empl1,empl2]</code></pre>
<p>That would return a tuple with the same information, without having to even declare <code>EmployeeProfile</code> as a Monoid, hence forcing a given monoid structure on those fields.</p>
<p>Thus, it is, as usual, a matter of what you intend to do with your data. If you have a long record, with the possibility of adding additional fields later, but you intend to combine them always in the same manner, the solution presented in this post has some clear advantages, since you don’t have to modify the monoid instance manually for each field.</p>
<p>But if you can see yourself needing to extract different information using different monoids, then perhaps you need the simpler data record, and instead you’ll use the <code>Monoid</code> <code>newtypes</code> on your functions, rather than your data structure.</p>
<p>It’s up to you, really :)</p>]]></summary>
</entry>
<entry>
    <title>From semigroups to bind</title>
    <link href="http://fundeps.com/posts/haskell/2014-03-05-from-semigroup-to-bind/index.html" />
    <id>http://fundeps.com/posts/haskell/2014-03-05-from-semigroup-to-bind/index.html</id>
    <published>2014-03-05T00:00:00Z</published>
    <updated>2014-03-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><em>tl;dr:</em> : what are Alt, Apply, Bind typeclasses</p>
<p>So, the one common comment I received on my first <a href="http://fundeps.com/posts/cheatsheets/2014-03-04-cheat-sheets/">haskell cheatsheet</a> was: it looks great, but I have no idea what half of those typeclasses are.</p>
<p>So, I guess an explanation is due.</p>
<p>My first glimpse of understanding came from this <a href="http://hackage.haskell.org/package/semigroupoids">beautiful ASCII art</a>, which I’ll reproduce here:</p>
<pre><code> Traversable &lt;---- Foldable &lt;--- Functor ------&gt; Alt ---------&gt; Plus           Semigroupoid
      |               |            |                              |                  |
      v               v            v                              v                  v
 Traversable1 &lt;--- Foldable1     Apply --------&gt; Applicative -&gt; Alternative      Category
                                   |               |              |                  |
                                   v               v              v                  v
                                 Bind ---------&gt; Monad -------&gt; MonadPlus          Arrow
</code></pre>
<p>So, for the regular haskeller without a background in mathematics,this is what it is usually known:</p>
<p><strong>Monoid</strong>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monoid</span> a <span class="kw">where</span>
<span class="ot">        mempty  ::</span> a
        <span class="co">-- ^ Identity of &#39;mappend&#39;</span>
<span class="ot">        mappend ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a
        <span class="co">-- ^ An associative operation</span>
<span class="ot">        mconcat ::</span> [a] <span class="ot">-&gt;</span> a</code></pre>
<p><strong>Functor</strong>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="kw">where</span>
<span class="ot">    fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p><strong>Applicative:</strong></p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Applicative</span> f <span class="kw">where</span>
    <span class="co">-- | Lift a value.</span>
<span class="ot">    pure ::</span> a <span class="ot">-&gt;</span> f a

    <span class="co">-- | Sequential application.</span>
<span class="ot">    (&lt;*&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p><strong>Alternative</strong>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="dt">Alternative</span> f <span class="kw">where</span>
    <span class="co">-- | The identity of &#39;&lt;|&gt;&#39;</span>
<span class="ot">    empty ::</span> f a
    <span class="co">-- | An associative binary operation</span>
<span class="ot">    (&lt;|&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</code></pre>
<h2 id="so-what-are-all-those-new-typeclasses">So, what are all those new typeclasses?</h2>
<h4 id="first-question-what-can-i-get-if-i-remove-the-identity-from-a-monoid">First question: <strong>what can I get if I remove the identity (from a Monoid)</strong>?</h4>
<p>You get a <a href="http://hackage.haskell.org/package/semigroups"><strong>semigroup</strong></a></p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Semigroup</span> a <span class="kw">where</span>
  <span class="co">-- | An associative operation.</span>
<span class="ot">  (&lt;&gt;) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</code></pre>
<p><em>But, what does it do, that a monoid doesn’t?</em></p>
<p>It gives you <a href="http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-Semigroup.html#t:Min">Min</a> and <a href="http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-Semigroup.html#t:Max">Max</a>. This would not be possible with a monoid. What’s the identity of a Maximum? Do you want to define that?</p>
<p>Plus, you get more instances than you get with monoids, namely <a href="http://hackage.haskell.org/package/semigroups-0.12.2/docs/Data-List-NonEmpty.html">Data.List.NonEmpty</a>. This is a list that is type checked to always have at least one element, and thus functions like head always succeed. On the other hand, since there is no ‘empty’ element, this type can only be an instance of Semigroup.</p>
<h4 id="second-question-what-can-i-get-if-i-remove-the-empty-from-an-alternative">Second question: <strong>what can I get if I remove the empty (from an Alternative)</strong>?</h4>
<h5 id="bonus-question-can-i-get-something-that-behaves-like-an-alternative-just-with-a-functor-constraint">Bonus question: <strong>can I get something that behaves like an alternative, just with a Functor constraint?</strong></h5>
<p><em>Yes: It’s called an <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Alt.html">Alt</a></em>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Alt</span> f <span class="kw">where</span>
  <span class="co">-- | @(&lt;|&gt;)@ without a required @empty@</span>
<span class="ot">    (&lt;!&gt;) ::</span> f a <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</code></pre>
<p><em>But, what does it do, that a alternative doesn’t?</em></p>
<p>It allows you to include some extra types, like <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Either.html">Either</a> or IO. Thus, you can write stuff like</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell">(<span class="fu">...</span>)
<span class="kw">do</span>
	<span class="co">-- IOAction1 `orElse` IOAction2</span>
	xpto <span class="ot">&lt;-</span> <span class="dt">IOAction1</span> <span class="fu">&lt;!&gt;</span> <span class="dt">IOAction2</span></code></pre>
<h4 id="third-question-what-can-i-get-if-i-remove-the-pure-from-an-applicative">Third question: <strong>what can I get if I remove the pure from an Applicative</strong>?</h4>
<p>An <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Apply.html#t:Apply">Apply</a>:</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="co">-- &gt; associative composition: (.) &lt;$&gt; u &lt;.&gt; v &lt;.&gt; w = u &lt;.&gt; (v &lt;.&gt; w)</span>
<span class="kw">class</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Apply</span> f <span class="kw">where</span>
<span class="ot">  (&lt;.&gt;) ::</span> f (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</code></pre>
<p><em>But, what does it do, that a applicative doesn’t?</em></p>
<p>It allows you to include some extra types, like <a href="http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-IntMap-Lazy.html">IntMap</a></p>
<h4 id="fourth-question-what-can-i-get-if-i-remove-the-return-from-a-monad">Fourth question: <strong>what can I get if I remove the return from a Monad</strong>?</h4>
<p>A <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Bind.html#t:Bind">Bind</a></p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Apply</span> m <span class="ot">=&gt;</span> <span class="dt">Bind</span> m <span class="kw">where</span>
<span class="ot">  (&gt;&gt;-) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b
  m <span class="fu">&gt;&gt;-</span> f <span class="fu">=</span> join (fmap f m)

<span class="ot">  join ::</span> m (m a) <span class="ot">-&gt;</span> m a
  join <span class="fu">=</span> (<span class="fu">&gt;&gt;-</span> id)</code></pre>
<p><em>But, what does it do, that a monad doesn’t?</em></p>
<p>It allows you to include some extra types, like <a href="http://hackage.haskell.org/package/containers-0.5.4.0/docs/Data-IntMap-Lazy.html">IntMap</a></p>
<h4 id="fifth-question-can-i-add-a-zero-value-to-alt">Fifth question: <strong>Can I add a <code>zero</code> value to Alt</strong>?</h4>
<p>Well, this one does seem a little bit far fetched, doesn’t it, since one of the steps of defining Alt was precisely to drop the empty… but, not just that (also just depending on Functor, and not Applicative instances). Hence, <code>zero</code> arrives. Once again, you do gain some extra instances (for example):</p>
<pre class="sourceCode Haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Plus</span> <span class="dt">IO</span> <span class="kw">where</span>
  zero <span class="fu">=</span> error <span class="st">&quot;zero&quot;</span>

<span class="kw">instance</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> <span class="dt">Plus</span> (<span class="dt">Map</span> k) <span class="kw">where</span>
  zero <span class="fu">=</span> Map.empty</code></pre>
<p>I call it <em>the reliable empty</em>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>See what I did here? Noticed the pattern?</p>
<p>As an important final note, while you might be mostly used to:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html#t:mempty">mempty</a> means empty</li>
<li><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html#t:mappend">mappend</a> means appending</li>
<li>Alternatives means choice</li>
</ul>
<p>Those are assumptions that do not hold for all types (as I ilustrate on the second page of the <a href="http://fundeps.com/tables/FromSemigroupToMonads.pdf">cheatsheet</a> ).</p>
<p>In fact, once you start thinking about monoids/semigroups as simply <em>binary operations</em>, you start seeing them everywhere, and you start appreciating the usefulness of sometimes dropping the identity/empty/return, etc.</p>
<p><a href="/posts/haskell/2014-03-12-Monoids-Newtypes-and-HR/">In my next post</a> I will ilustrate this, and show how to automatically derive Monoid instances, dramatically reducing your boilerplate.</p>
<p>As usual, please report any typo, error, or gross misundertanding on my part to the email below. Thanks!</p>]]></summary>
</entry>
<entry>
    <title>Haskell Cheat Sheets (Part 1)</title>
    <link href="http://fundeps.com/posts/cheatsheets/2014-03-04-cheat-sheets/index.html" />
    <id>http://fundeps.com/posts/cheatsheets/2014-03-04-cheat-sheets/index.html</id>
    <published>2014-03-04T00:00:00Z</published>
    <updated>2014-03-04T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><em>tl;dr:</em> : see <a href="/tables/FromSemigroupToMonads.pdf">this</a>.</p>
<p>If you look for Haskell cheat sheets on the web, you get:</p>
<ul>
<li><a href="http://cheatsheet.codeslower.com/CheatSheet.pdf">Code Slower 14 pages cheat sheet</a></li>
<li><a href="http://www.haskell.org/haskellwiki/Reference_card">Haskell Wiki Reference Card</a></li>
<li><a href="http://www.cheat-sheets.org/saved-copy/Haskell.Haskell_Cheat_Sheet.pdf">A short one with the basics</a></li>
<li><a href="https://wincent.com/wiki/Haskell_cheat_sheet">And another one</a></li>
<li><a href="https://github.com/rudymatela/ultimate-cheat-sheets">Ultimate Haskell Cheat Sheet</a></li>
</ul>
<p>Personally, I find none of them particular useful. While the last three are useful for the absolute beginner, it seems that there’s a gap from there forward.</p>
<p>Of course, the usual answer is <a href="https://stackoverflow.com/questions/1162360/haskell-function-cheat-sheet">why do you need a cheat sheet, if there is hoogle</a>, but while <a href="http://www.haskell.org/hoogle/">hoogle</a> and <a href="http://holumbus.fh-wedel.de/hayoo/hayoo.html">hayoo</a> are great, they only help you when you know what you are looking for exactly, namely the type signature.</p>
<p>Sometimes, it is useful to just have a lot information condensed in such a way that’s easy to analyse, so that you can make informed decisions or just easily discover additional functions.</p>
<p>With that purpose in mind, I plan to launch some Haskell cheat sheets, with different levels of complexity and applicability, but with some clear goals in mind:</p>
<ul>
<li>Succinct</li>
<li>Ready to print, for the paper lovers like me</li>
<li>Frequently updated and thus, one expects, always correct</li>
</ul>
<p>The first Haskell sheet cheat I’ll be releasing is one were I illustrate:</p>
<ul>
<li><a href="http://hackage.haskell.org/package/semigroups">Semigroup</a> , <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Monoid.html">Monoid</a> , <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Alt.html">Alt</a> , <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Plus.html">Plus</a> , <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Apply.html">Apply</a> , <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Applicative">Applicative</a> , <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Alternative">Alternative</a> , <a href="http://hackage.haskell.org/package/semigroupoids-4.0/docs/Data-Functor-Bind.html">Bind</a> , <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> , <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:MonadPlus">MonadPlus</a> hierarchy</li>
<li>Fundamental operations supported by each type class</li>
<li>Semantics of the binary operation (Choice, Combination, Both, Neither)</li>
<li>Type Class restrictions</li>
</ul>
<div class="figure">
<img src="/images/fromsemigroup.png" />
</div>
<p><strong>You can get it <a href="/tables/FromSemigroupToMonads.pdf">here</a>.</strong></p>
<p><strong>If you don’t know half of those type classes, please see my <a href="http://fundeps.com/posts/haskell/2014-03-05-from-semigroup-to-bind">next post</a>, for a quick and dirty introduction.</strong></p>
<p>These tables were made incrementally as I was learning each type class. They are still incomplete (namely the second page is still a partial copy-paste of the first), and they are - get ready to puke - in <a href="https://github.com/jcristovao/haskell-cheatsheets">LibreOffice format</a>, not Latex. But for these really complex tables I find it more useful: but I’m open to suggestions.</p>
<p>There are probably some lingering errors, and the table were not, unfortunately, made through automated code analysis. I would very much like that, but right now I see it as a very time consuming task…</p>
<p>Please feel free to identify mistakes, make suggestions or otherwise give your feedback on these. The original file is <a href="https://github.com/jcristovao/haskell-cheatsheets">at GitHub</a>.</p>
<p>Thanks!</p>]]></summary>
</entry>

</feed>
